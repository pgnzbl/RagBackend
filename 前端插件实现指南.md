# 前端插件实现指南 - 切分策略功能

本文档提供前端插件实现切分策略功能的详细指南和代码示例。

## 功能概述

允许用户在上传文件时选择不同的文本切分策略，包括：
- **fixed**: 固定长度切分（默认）
- **newline**: 按换行符切分
- **paragraph**: 按段落切分（双换行）
- **sentence**: 按句子切分
- **smart**: 智能切分

## 实现步骤

### 1. 添加切分策略选择UI组件

#### HTML结构示例

```html
<div class="upload-section">
  <h3>上传文件到知识库</h3>
  
  <!-- 文件选择 -->
  <div class="file-select">
    <label>选择文件：</label>
    <input type="file" id="fileInput" accept=".pdf,.txt,.docx,.md">
  </div>
  
  <!-- 切分策略选择 -->
  <div class="split-strategy">
    <label>切分策略：</label>
    <select id="splitStrategySelect">
      <option value="">加载中...</option>
    </select>
    <span class="strategy-description" id="strategyDescription"></span>
  </div>
  
  <!-- 高级设置（可折叠） -->
  <details class="advanced-settings">
    <summary>高级设置</summary>
    <div class="settings-content">
      <div class="setting-item">
        <label>Chunk大小（字符数）：</label>
        <input type="number" id="chunkSizeInput" value="400" min="50" max="2000">
      </div>
      <div class="setting-item">
        <label>重叠大小：</label>
        <input type="number" id="chunkOverlapInput" value="50" min="0" max="500">
      </div>
    </div>
  </details>
  
  <!-- 上传按钮 -->
  <button id="uploadBtn" onclick="handleUpload()">上传文件</button>
</div>
```

#### CSS样式示例

```css
.upload-section {
  padding: 20px;
}

.split-strategy {
  margin: 15px 0;
}

.split-strategy select {
  padding: 8px;
  font-size: 14px;
  min-width: 200px;
}

.strategy-description {
  display: block;
  margin-top: 5px;
  color: #666;
  font-size: 12px;
}

.advanced-settings {
  margin: 15px 0;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 10px;
}

.settings-content {
  margin-top: 10px;
}

.setting-item {
  margin: 10px 0;
}

.setting-item label {
  display: inline-block;
  width: 150px;
}

.setting-item input {
  padding: 5px;
  width: 100px;
}
```

### 2. 获取策略列表功能

```javascript
// API基础URL（根据实际情况修改）
const API_BASE_URL = 'http://localhost:8000';

// 获取切分策略列表
async function getSplitStrategies() {
  try {
    const response = await fetch(`${API_BASE_URL}/kb/split-strategies`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    const data = await response.json();
    return data.strategies || {};
  } catch (error) {
    console.error('获取切分策略失败:', error);
    return {};
  }
}

// 加载策略到下拉框
async function loadStrategiesToSelect() {
  const select = document.getElementById('splitStrategySelect');
  const strategies = await getSplitStrategies();
  
  select.innerHTML = '';
  
  for (const [key, description] of Object.entries(strategies)) {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = `${key} - ${description}`;
    select.appendChild(option);
  }
  
  // 设置默认值
  select.value = 'fixed';
  updateStrategyDescription('fixed', strategies);
}

// 更新策略说明
function updateStrategyDescription(strategy, strategies) {
  const descElement = document.getElementById('strategyDescription');
  if (strategies[strategy]) {
    descElement.textContent = strategies[strategy];
  }
}

// 监听策略选择变化
document.addEventListener('DOMContentLoaded', async () => {
  await loadStrategiesToSelect();
  
  const select = document.getElementById('splitStrategySelect');
  const strategies = await getSplitStrategies();
  
  select.addEventListener('change', (e) => {
    updateStrategyDescription(e.target.value, strategies);
  });
});
```

### 3. 更新文件上传函数

```javascript
// 上传文件函数（支持切分策略参数）
async function uploadFile(kbName, file, splitStrategy = 'fixed', chunkSize = 400, chunkOverlap = 50) {
  const formData = new FormData();
  formData.append('file', file);
  
  // 构建查询参数
  const params = new URLSearchParams({
    split_strategy: splitStrategy,
    chunk_size: chunkSize.toString(),
    chunk_overlap: chunkOverlap.toString()
  });
  
  try {
    const response = await fetch(`${API_BASE_URL}/kb/${encodeURIComponent(kbName)}/upload?${params}`, {
      method: 'POST',
      body: formData,
      // 注意：不要设置Content-Type，浏览器会自动设置multipart/form-data
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || `HTTP ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('上传文件失败:', error);
    throw error;
  }
}

// 处理上传按钮点击
async function handleUpload() {
  const fileInput = document.getElementById('fileInput');
  const kbName = getSelectedKBName(); // 获取当前选中的知识库名称
  const splitStrategy = document.getElementById('splitStrategySelect').value;
  const chunkSize = parseInt(document.getElementById('chunkSizeInput').value);
  const chunkOverlap = parseInt(document.getElementById('chunkOverlapInput').value);
  
  if (!fileInput.files || fileInput.files.length === 0) {
    alert('请选择文件');
    return;
  }
  
  if (!splitStrategy) {
    alert('请选择切分策略');
    return;
  }
  
  // 验证参数
  if (chunkSize <= 0) {
    alert('Chunk大小必须大于0');
    return;
  }
  
  if (chunkOverlap < 0 || chunkOverlap >= chunkSize) {
    alert('重叠大小必须大于等于0且小于Chunk大小');
    return;
  }
  
  const file = fileInput.files[0];
  
  // 显示加载状态
  const uploadBtn = document.getElementById('uploadBtn');
  uploadBtn.disabled = true;
  uploadBtn.textContent = '上传中...';
  
  try {
    const result = await uploadFile(kbName, file, splitStrategy, chunkSize, chunkOverlap);
    
    alert(`上传成功！\n文件：${result.filename}\nChunks数量：${result.chunks_count}`);
    
    // 清空文件选择
    fileInput.value = '';
    
    // 刷新文档列表
    refreshDocumentList(kbName);
  } catch (error) {
    alert(`上传失败：${error.message}`);
  } finally {
    uploadBtn.disabled = false;
    uploadBtn.textContent = '上传文件';
  }
}
```

### 4. Chrome插件环境中的实现

如果是Chrome插件，需要使用Chrome的文件API：

```javascript
// Chrome插件中上传文件
async function uploadFileFromChrome(kbName, fileEntry, splitStrategy = 'fixed', chunkSize = 400, chunkOverlap = 50) {
  return new Promise((resolve, reject) => {
    fileEntry.file((file) => {
      const formData = new FormData();
      formData.append('file', file);
      
      // 构建查询参数
      const params = new URLSearchParams({
        split_strategy: splitStrategy,
        chunk_size: chunkSize.toString(),
        chunk_overlap: chunkOverlap.toString()
      });
      
      fetch(`${API_BASE_URL}/kb/${encodeURIComponent(kbName)}/upload?${params}`, {
        method: 'POST',
        body: formData,
      })
      .then(response => {
        if (!response.ok) {
          return response.json().then(err => Promise.reject(new Error(err.detail || `HTTP ${response.status}`)));
        }
        return response.json();
      })
      .then(resolve)
      .catch(reject);
    }, reject);
  });
}
```

### 5. 完整示例代码

```javascript
// 完整的插件实现示例
class FileUploader {
  constructor(apiBaseUrl) {
    this.apiBaseUrl = apiBaseUrl;
    this.strategies = {};
  }
  
  async init() {
    await this.loadStrategies();
    this.setupEventListeners();
  }
  
  async loadStrategies() {
    try {
      const response = await fetch(`${this.apiBaseUrl}/kb/split-strategies`);
      const data = await response.json();
      this.strategies = data.strategies || {};
      this.populateStrategySelect();
    } catch (error) {
      console.error('加载策略失败:', error);
    }
  }
  
  populateStrategySelect() {
    const select = document.getElementById('splitStrategySelect');
    select.innerHTML = '';
    
    for (const [key, description] of Object.entries(this.strategies)) {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = `${key} - ${description}`;
      select.appendChild(option);
    }
    
    select.value = 'fixed';
    this.updateDescription('fixed');
  }
  
  updateDescription(strategy) {
    const descElement = document.getElementById('strategyDescription');
    if (this.strategies[strategy]) {
      descElement.textContent = this.strategies[strategy];
    }
  }
  
  setupEventListeners() {
    const select = document.getElementById('splitStrategySelect');
    select.addEventListener('change', (e) => {
      this.updateDescription(e.target.value);
    });
    
    const uploadBtn = document.getElementById('uploadBtn');
    uploadBtn.addEventListener('click', () => this.handleUpload());
  }
  
  async handleUpload() {
    const fileInput = document.getElementById('fileInput');
    const kbName = this.getCurrentKBName();
    const splitStrategy = document.getElementById('splitStrategySelect').value;
    const chunkSize = parseInt(document.getElementById('chunkSizeInput').value);
    const chunkOverlap = parseInt(document.getElementById('chunkOverlapInput').value);
    
    if (!this.validateInput(fileInput, splitStrategy, chunkSize, chunkOverlap)) {
      return;
    }
    
    const file = fileInput.files[0];
    
    try {
      const result = await this.uploadFile(kbName, file, splitStrategy, chunkSize, chunkOverlap);
      this.showSuccess(result);
      fileInput.value = '';
    } catch (error) {
      this.showError(error);
    }
  }
  
  validateInput(fileInput, splitStrategy, chunkSize, chunkOverlap) {
    if (!fileInput.files || fileInput.files.length === 0) {
      alert('请选择文件');
      return false;
    }
    
    if (!splitStrategy) {
      alert('请选择切分策略');
      return false;
    }
    
    if (chunkSize <= 0) {
      alert('Chunk大小必须大于0');
      return false;
    }
    
    if (chunkOverlap < 0 || chunkOverlap >= chunkSize) {
      alert('重叠大小必须大于等于0且小于Chunk大小');
      return false;
    }
    
    return true;
  }
  
  async uploadFile(kbName, file, splitStrategy, chunkSize, chunkOverlap) {
    const formData = new FormData();
    formData.append('file', file);
    
    const params = new URLSearchParams({
      split_strategy: splitStrategy,
      chunk_size: chunkSize.toString(),
      chunk_overlap: chunkOverlap.toString()
    });
    
    const response = await fetch(`${this.apiBaseUrl}/kb/${encodeURIComponent(kbName)}/upload?${params}`, {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || `HTTP ${response.status}`);
    }
    
    return await response.json();
  }
  
  getCurrentKBName() {
    // 根据实际插件实现获取当前知识库名称
    // 例如：从下拉框、localStorage等获取
    return 'my_kb';
  }
  
  showSuccess(result) {
    alert(`上传成功！\n文件：${result.filename}\nChunks数量：${result.chunks_count}`);
    // 可以触发自定义事件或回调，通知其他组件刷新
  }
  
  showError(error) {
    alert(`上传失败：${error.message}`);
  }
}

// 初始化
document.addEventListener('DOMContentLoaded', () => {
  const uploader = new FileUploader('http://localhost:8000');
  uploader.init();
});
```

## 测试要点

1. **测试所有策略**：确保每种切分策略都能正常工作
2. **测试参数验证**：测试无效参数（负数、过大的值等）的处理
3. **测试向后兼容**：不传参数时使用默认值
4. **测试UI交互**：策略选择、高级设置的显示/隐藏
5. **测试错误处理**：网络错误、API错误的提示

## 注意事项

1. **URL编码**：知识库名称可能包含中文字符，需要使用 `encodeURIComponent()` 编码
2. **Content-Type**：上传文件时不要手动设置 `Content-Type`，浏览器会自动设置
3. **错误处理**：提供友好的错误提示
4. **加载状态**：上传过程中显示加载状态，禁用按钮防止重复提交
5. **参数验证**：前端也要进行参数验证，提供即时反馈

## API参考

详细的API文档请参考：[API_对接文档.md](API_对接文档.md)

